import { isPostRenderPlugin, Renderer } from '../renderer';
import { UnrecognizedTagError } from './errors';
export class DOMRenderer extends Renderer {
    constructor(dom = window, ...plugins) {
        super(...(typeof dom === 'function' ? [dom, ...plugins] : plugins));
        if (!dom || typeof dom === 'function') {
            this.dom = window;
        }
        else {
            this.dom = dom;
        }
    }
    get document() { return this.dom.document; }
    fallbackAppend(target, host) {
        if (target instanceof this.dom.Node) {
            host.appendChild(target);
        }
        else if (Array.isArray(target)) {
            target.forEach(child => this.append(child, host));
        }
        else {
            host.appendChild(this.document.createTextNode(`${target}`));
        }
    }
    fallbackSetProp(node, prop, target) {
        if (node instanceof this.dom.HTMLElement) {
            if (typeof target === 'boolean') {
                if (target) {
                    node.setAttribute(prop, '');
                }
                else {
                    node.removeAttribute(prop);
                }
            }
            else {
                node.setAttribute(prop, `${target}`);
            }
        }
    }
    fallbackSetContent(node, target) {
        if (node instanceof this.dom.HTMLElement) {
            node.innerHTML = `${target}`;
        }
        else {
            node.textContent = `${target}`;
        }
    }
    fallbackFragment() {
        return this.document.createDocumentFragment();
    }
    fallbackLeaf() {
        return this.document.createTextNode('');
    }
    fallbackCreate(tag, props) {
        if (!(tag instanceof this.dom.Node || typeof tag === 'string')) {
            throw new UnrecognizedTagError(tag);
        }
        if (tag instanceof this.dom.Node) {
            return tag;
        }
        else if (props && props.xmlns) {
            return this.document.createElementNS(`${props.xmlns}`, tag);
        }
        else {
            return this.document.createElement(tag);
        }
    }
    renderOn(target, host) {
        host.appendChild(target);
    }
    renderAfter(target, ref) {
        if (ref.parentNode) {
            ref.parentNode.insertBefore(target, ref.nextSibling);
        }
    }
    renderBefore(target, ref) {
        if (ref.parentNode) {
            ref.parentNode.insertBefore(target, ref);
        }
    }
    postRender(target) {
        const post = this.plugins.filter(isPostRenderPlugin);
        if (target instanceof this.dom.DocumentFragment) {
            const children = Array.from(target.childNodes);
            return () => children.forEach(child => { this.postRender(child)(); });
        }
        else {
            return () => post.forEach(p => p.postRender(target));
        }
    }
    remove(node) {
        var _a;
        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);
    }
    clone(...plugins) {
        return new DOMRenderer(this.dom, ...plugins);
    }
}
//# sourceMappingURL=renderer.js.map