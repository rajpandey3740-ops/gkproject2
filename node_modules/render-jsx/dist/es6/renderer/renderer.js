import { isAppendPlugin, isPropPlugin, isContentPlugin, isFragmentPlugin, isCreatePlugin, isPostCreatePlugin, isPostRenderPlugin, isLeafPlugin } from './plugin';
export class Renderer {
    constructor(...plugins) {
        this._appendPlugins = [];
        this._createPlugins = [];
        this._propPlugins = [];
        this._contentPlugins = [];
        this._postCreatePlugins = [];
        this._postRenderPlugins = [];
        this._factories = plugins;
    }
    _buildPlugins() {
        if (!this._plugins) {
            this._plugins = this._factories.map(f => f()).sort((a, b) => b.priority() - a.priority());
            this._plugins.forEach(p => {
                p.plug(this);
                if (isAppendPlugin(p)) {
                    this._appendPlugins.push(p);
                }
                if (isContentPlugin(p)) {
                    this._contentPlugins.push(p);
                }
                if (isPropPlugin(p)) {
                    this._propPlugins.push(p);
                }
                if (isCreatePlugin(p)) {
                    this._createPlugins.push(p);
                }
                if (isPostCreatePlugin(p)) {
                    this._postCreatePlugins.push(p);
                }
                if (isPostRenderPlugin(p)) {
                    this._postRenderPlugins.push(p);
                }
                if (isLeafPlugin(p) && !this._leafPlugin) {
                    this._leafPlugin = p;
                }
                if (isFragmentPlugin(p) && !this._fragmentPlugin) {
                    this._fragmentPlugin = p;
                }
            });
        }
        return this;
    }
    get plugins() { return this._buildPlugins() && this._plugins; }
    get appendPlugins() { return this._buildPlugins() && this._appendPlugins; }
    get contentPlugins() { return this._buildPlugins() && this._contentPlugins; }
    get propPlugins() { return this._buildPlugins() && this._propPlugins; }
    get createPlugins() { return this._buildPlugins() && this._createPlugins; }
    get postCreatePlugins() { return this._buildPlugins() && this._postCreatePlugins; }
    get postRenderPlugins() { return this._buildPlugins() && this._postRenderPlugins; }
    get leafPlugin() { return this._buildPlugins() && this._leafPlugin; }
    get fragmentPlugin() { return this._buildPlugins() && this._fragmentPlugin; }
    plug(...plugins) {
        return this.clone(...this._factories, ...plugins);
    }
    append(target, host) {
        if (!this.appendPlugins.some(p => p.append(target, host))) {
            this.fallbackAppend(target, host);
        }
    }
    setProp(node, prop, target) {
        if (!this.propPlugins.some(p => p.setProp(node, prop, target))) {
            this.fallbackSetProp(node, prop, target);
        }
    }
    setContent(node, target) {
        if (!this.contentPlugins.some(p => p.setContent(node, target))) {
            this.fallbackSetContent(node, target);
        }
    }
    get fragment() {
        const plugin = this.fragmentPlugin;
        return plugin ? plugin.fragment() : this.fallbackFragment();
    }
    leaf() {
        const plugin = this.leafPlugin;
        return plugin ? plugin.leaf() : this.fallbackLeaf();
    }
    create(tag, props, ...children) {
        let candidate = undefined;
        for (const p of this.createPlugins) {
            candidate = p.create(tag, props, ...children);
            if (candidate) {
                break;
            }
        }
        if (!candidate) {
            candidate = this.fallbackCreate(tag, props);
            if (props) {
                Object.entries(props).forEach(([prop, target]) => this.setProp(candidate, prop, target));
            }
            children.forEach(child => this.append(child, candidate));
        }
        this.postCreatePlugins.forEach(p => p.postCreate(candidate));
        return candidate;
    }
    render(target) {
        if (typeof target === 'function') {
            return this.render(target.apply(undefined, [this]));
        }
        const _this = this;
        const post = this.postRender(target);
        return {
            after(ref) {
                _this.renderAfter(target, ref);
                post();
            },
            before(ref) {
                _this.renderBefore(target, ref);
                post();
            },
            on(host) {
                _this.renderOn(target, host);
                post();
            },
            target,
        };
    }
    postRender(target) {
        return () => this.postRenderPlugins.forEach(p => p.postRender(target));
    }
}
//# sourceMappingURL=renderer.js.map